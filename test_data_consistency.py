"""
Test de coh√©rence des donn√©es entre le tableau de bord web et la base de donn√©es SQLite
V√©rifie que les donn√©es affich√©es correspondent exactement aux donn√©es stock√©es
"""

import requests
import sqlite3
import json
from datetime import datetime, timedelta
import sqlite_database as db
import sqlite_config as config

class DataConsistencyTester:
    def __init__(self):
        self.session = requests.Session()
        self.dashboard_url = "http://localhost:5001"
        self.db_path = "attendance.db"
        self.logged_in = False
        
    def login(self):
        """Se connecter au tableau de bord"""
        print("üîê Connexion au tableau de bord...")
        
        try:
            # Page de connexion
            response = self.session.get(f"{self.dashboard_url}/login")
            if response.status_code != 200:
                print(f"‚ùå Erreur page de connexion: {response.status_code}")
                return False
            
            # Connexion
            login_data = {'username': 'admin', 'password': 'admin123'}
            response = self.session.post(f"{self.dashboard_url}/login", data=login_data)
            
            if response.status_code == 200 and "dashboard" in response.url:
                print("‚úÖ Connexion r√©ussie")
                self.logged_in = True
                return True
            else:
                print(f"‚ùå √âchec de la connexion: {response.status_code}")
                return False
                
        except Exception as e:
            print(f"‚ùå Erreur de connexion: {e}")
            return False
    
    def get_dashboard_stats(self):
        """R√©cup√©rer les statistiques du tableau de bord"""
        print("\nüìä R√©cup√©ration des statistiques du tableau de bord...")
        
        try:
            response = self.session.get(f"{self.dashboard_url}/api/stats")
            if response.status_code == 200:
                data = response.json()
                print("‚úÖ Statistiques dashboard r√©cup√©r√©es")
                return data
            else:
                print(f"‚ùå Erreur API stats: {response.status_code}")
                return None
                
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration stats: {e}")
            return None
    
    def get_database_stats(self):
        """R√©cup√©rer les statistiques directement de la base de donn√©es"""
        print("\nüóÑÔ∏è R√©cup√©ration des statistiques de la base de donn√©es...")
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Compter les √©tudiants
            cursor.execute("SELECT COUNT(*) FROM etudiants")
            total_students = cursor.fetchone()[0]
            
            # Compter toutes les pr√©sences
            cursor.execute("SELECT COUNT(*) FROM presences")
            total_attendance = cursor.fetchone()[0]
            
            # Pr√©sences aujourd'hui
            today = datetime.now().strftime("%Y-%m-%d")
            cursor.execute("SELECT COUNT(*) FROM presences WHERE date = ?", (today,))
            today_attendance = cursor.fetchone()[0]
            
            # Pr√©sences cette semaine
            week_ago = (datetime.now() - timedelta(days=7)).strftime("%Y-%m-%d")
            cursor.execute("SELECT COUNT(*) FROM presences WHERE date >= ?", (week_ago,))
            week_attendance = cursor.fetchone()[0]
            
            conn.close()
            
            db_stats = {
                'total_students': total_students,
                'total_attendance': total_attendance,
                'today_attendance': today_attendance,
                'week_attendance': week_attendance
            }
            
            print("‚úÖ Statistiques base de donn√©es r√©cup√©r√©es")
            return db_stats
            
        except Exception as e:
            print(f"‚ùå Erreur base de donn√©es: {e}")
            return None
    
    def get_dashboard_students(self):
        """R√©cup√©rer la liste des √©tudiants depuis le dashboard"""
        print("\nüë• R√©cup√©ration des √©tudiants du tableau de bord...")
        
        try:
            # Acc√©der √† la page des √©tudiants
            response = self.session.get(f"{self.dashboard_url}/students")
            if response.status_code == 200:
                # Utiliser l'API pour obtenir les donn√©es
                students = db.obtenir_tous_etudiants()
                print(f"‚úÖ {len(students)} √©tudiants r√©cup√©r√©s du dashboard")
                return students
            else:
                print(f"‚ùå Erreur page √©tudiants: {response.status_code}")
                return None
                
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration √©tudiants dashboard: {e}")
            return None
    
    def get_database_students(self):
        """R√©cup√©rer la liste des √©tudiants directement de la base de donn√©es"""
        print("\nüóÑÔ∏è R√©cup√©ration des √©tudiants de la base de donn√©es...")
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT id_etudiant, nom, prenom, email, telephone, date_creation
                FROM etudiants
                ORDER BY id_etudiant
            """)
            
            rows = cursor.fetchall()
            students = []
            
            for row in rows:
                students.append({
                    'id_etudiant': row[0],
                    'nom': row[1],
                    'prenom': row[2],
                    'email': row[3],
                    'telephone': row[4],
                    'date_creation': row[5]
                })
            
            conn.close()
            print(f"‚úÖ {len(students)} √©tudiants r√©cup√©r√©s de la base de donn√©es")
            return students
            
        except Exception as e:
            print(f"‚ùå Erreur base de donn√©es √©tudiants: {e}")
            return None
    
    def get_dashboard_attendance(self):
        """R√©cup√©rer les pr√©sences depuis le dashboard"""
        print("\nüìÖ R√©cup√©ration des pr√©sences du tableau de bord...")
        
        try:
            # Utiliser la fonction config pour obtenir toutes les pr√©sences
            attendance = config.get_all_attendance()
            print(f"‚úÖ {len(attendance)} pr√©sences r√©cup√©r√©es du dashboard")
            return attendance
            
        except Exception as e:
            print(f"‚ùå Erreur r√©cup√©ration pr√©sences dashboard: {e}")
            return None
    
    def get_database_attendance(self):
        """R√©cup√©rer les pr√©sences directement de la base de donn√©es"""
        print("\nüóÑÔ∏è R√©cup√©ration des pr√©sences de la base de donn√©es...")
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            cursor.execute("""
                SELECT nom, date, heure, timestamp
                FROM presences
                ORDER BY timestamp DESC
            """)
            
            rows = cursor.fetchall()
            attendance = []
            
            for row in rows:
                attendance.append({
                    'name': row[0],
                    'date': row[1],
                    'time': row[2],  # Keep 'time' for consistency with dashboard data
                    'timestamp': row[3]
                })
            
            conn.close()
            print(f"‚úÖ {len(attendance)} pr√©sences r√©cup√©r√©es de la base de donn√©es")
            return attendance
            
        except Exception as e:
            print(f"‚ùå Erreur base de donn√©es pr√©sences: {e}")
            return None
    
    def compare_statistics(self, dashboard_stats, db_stats):
        """Comparer les statistiques"""
        print("\nüìä COMPARAISON DES STATISTIQUES")
        print("=" * 60)
        
        if not dashboard_stats or not db_stats:
            print("‚ùå Impossible de comparer - donn√©es manquantes")
            return False
        
        all_match = True
        
        # Comparer chaque statistique
        stats_to_compare = [
            ('total_students', 'Total √©tudiants'),
            ('total_attendance', 'Total pr√©sences'),
            ('today_attendance', 'Pr√©sences aujourd\'hui'),
            ('week_attendance', 'Pr√©sences cette semaine')
        ]
        
        for key, label in stats_to_compare:
            dashboard_val = dashboard_stats.get(key, 'N/A')
            db_val = db_stats.get(key, 'N/A')
            
            if dashboard_val == db_val:
                print(f"‚úÖ {label}: {dashboard_val} (Dashboard) = {db_val} (DB)")
            else:
                print(f"‚ùå {label}: {dashboard_val} (Dashboard) ‚â† {db_val} (DB)")
                all_match = False
        
        return all_match
    
    def compare_students(self, dashboard_students, db_students):
        """Comparer les listes d'√©tudiants"""
        print("\nüë• COMPARAISON DES √âTUDIANTS")
        print("=" * 60)
        
        if not dashboard_students or not db_students:
            print("‚ùå Impossible de comparer - donn√©es manquantes")
            return False
        
        # Comparer les nombres
        dash_count = len(dashboard_students)
        db_count = len(db_students)
        
        print(f"üìä Nombre d'√©tudiants:")
        print(f"   Dashboard: {dash_count}")
        print(f"   Base de donn√©es: {db_count}")
        
        if dash_count != db_count:
            print("‚ùå DIFF√âRENCE dans le nombre d'√©tudiants!")
            return False
        
        # Comparer les d√©tails
        print(f"\nüîç V√©rification d√©taill√©e de {dash_count} √©tudiants...")
        
        # Cr√©er des dictionnaires pour comparaison facile
        # Dashboard uses 'IdEtudiant', 'NomEtudiant', etc.
        # Database direct query uses 'id_etudiant', 'nom', etc.
        dash_dict = {s['IdEtudiant']: s for s in dashboard_students}
        db_dict = {s['id_etudiant']: s for s in db_students}

        all_match = True

        for student_id in dash_dict:
            if student_id not in db_dict:
                print(f"‚ùå √âtudiant {student_id} pr√©sent dans dashboard mais pas en DB")
                all_match = False
                continue

            dash_student = dash_dict[student_id]
            db_student = db_dict[student_id]

            # Comparer les champs (mapping dashboard -> database field names)
            field_mapping = {
                'NomEtudiant': 'nom',
                'PrenomEtudiant': 'prenom',
                'EmailEtudiant': 'email',
                'TelephoneEtudiant': 'telephone'
            }

            for dash_field, db_field in field_mapping.items():
                dash_value = dash_student.get(dash_field)
                db_value = db_student.get(db_field)
                if dash_value != db_value:
                    print(f"‚ùå √âtudiant {student_id} - {db_field}: '{dash_value}' ‚â† '{db_value}'")
                    all_match = False
        
        # V√©rifier les √©tudiants uniquement en DB
        for student_id in db_dict:
            if student_id not in dash_dict:
                print(f"‚ùå √âtudiant {student_id} pr√©sent en DB mais pas dans dashboard")
                all_match = False
        
        if all_match:
            print("‚úÖ Tous les √©tudiants correspondent parfaitement")
        
        return all_match
    
    def compare_attendance(self, dashboard_attendance, db_attendance):
        """Comparer les pr√©sences"""
        print("\nüìÖ COMPARAISON DES PR√âSENCES")
        print("=" * 60)
        
        if not dashboard_attendance or not db_attendance:
            print("‚ùå Impossible de comparer - donn√©es manquantes")
            return False
        
        # Comparer les nombres
        dash_count = len(dashboard_attendance)
        db_count = len(db_attendance)
        
        print(f"üìä Nombre de pr√©sences:")
        print(f"   Dashboard: {dash_count}")
        print(f"   Base de donn√©es: {db_count}")
        
        if dash_count != db_count:
            print("‚ùå DIFF√âRENCE dans le nombre de pr√©sences!")
            return False
        
        print(f"‚úÖ M√™me nombre de pr√©sences: {dash_count}")
        
        # V√©rification par √©chantillonnage (10 premiers et 10 derniers)
        print(f"\nüîç V√©rification par √©chantillonnage...")
        
        sample_size = min(10, len(dashboard_attendance))
        all_match = True
        
        # Comparer les premiers enregistrements
        for i in range(sample_size):
            dash_record = dashboard_attendance[i]
            db_record = db_attendance[i]
            
            if (dash_record.get('name') != db_record.get('name') or
                dash_record.get('date') != db_record.get('date') or
                dash_record.get('time') != db_record.get('time')):
                print(f"‚ùå Pr√©sence {i+1}: Diff√©rence d√©tect√©e")
                print(f"   Dashboard: {dash_record}")
                print(f"   DB: {db_record}")
                all_match = False
        
        if all_match:
            print(f"‚úÖ √âchantillon de {sample_size} pr√©sences correspond parfaitement")
        
        return all_match
    
    def run_full_comparison(self):
        """Ex√©cuter la comparaison compl√®te"""
        print("üîç TEST DE COH√âRENCE DES DONN√âES")
        print("=" * 60)
        print("Comparaison entre le tableau de bord web et la base de donn√©es SQLite")
        print()
        
        # Connexion
        if not self.login():
            print("‚ùå Impossible de se connecter au dashboard")
            return False
        
        # R√©cup√©rer toutes les donn√©es
        print("\nüì• R√âCUP√âRATION DES DONN√âES")
        print("=" * 60)
        
        dashboard_stats = self.get_dashboard_stats()
        db_stats = self.get_database_stats()
        
        dashboard_students = self.get_dashboard_students()
        db_students = self.get_database_students()
        
        dashboard_attendance = self.get_dashboard_attendance()
        db_attendance = self.get_database_attendance()
        
        # Comparaisons
        print("\nüîç COMPARAISONS D√âTAILL√âES")
        print("=" * 60)
        
        stats_match = self.compare_statistics(dashboard_stats, db_stats)
        students_match = self.compare_students(dashboard_students, db_students)
        attendance_match = self.compare_attendance(dashboard_attendance, db_attendance)
        
        # R√©sum√© final
        print("\nüìã R√âSUM√â DE LA COH√âRENCE DES DONN√âES")
        print("=" * 60)
        
        print(f"Statistiques: {'‚úÖ COH√âRENTES' if stats_match else '‚ùå INCOH√âRENTES'}")
        print(f"√âtudiants: {'‚úÖ COH√âRENTS' if students_match else '‚ùå INCOH√âRENTS'}")
        print(f"Pr√©sences: {'‚úÖ COH√âRENTES' if attendance_match else '‚ùå INCOH√âRENTES'}")
        
        all_consistent = stats_match and students_match and attendance_match
        
        print(f"\nüéØ R√âSULTAT GLOBAL: {'‚úÖ DONN√âES COH√âRENTES' if all_consistent else '‚ùå INCOH√âRENCES D√âTECT√âES'}")
        
        if all_consistent:
            print("\nüéâ EXCELLENT! Le tableau de bord affiche des donn√©es parfaitement coh√©rentes")
            print("   ‚úÖ Aucune discordance entre l'interface web et la base de donn√©es")
            print("   ‚úÖ Les statistiques sont exactes")
            print("   ‚úÖ Les listes d'√©tudiants correspondent")
            print("   ‚úÖ Les enregistrements de pr√©sences sont coh√©rents")
        else:
            print("\n‚ö†Ô∏è PROBL√àMES DE COH√âRENCE D√âTECT√âS")
            print("   Causes possibles:")
            print("   - Probl√®mes de cache dans l'application web")
            print("   - Requ√™tes SQL incorrectes dans le dashboard")
            print("   - Synchronisation incompl√®te entre modules")
            print("   - Transactions de base de donn√©es non commit√©es")
        
        return all_consistent

def main():
    """Fonction principale"""
    print("üéØ TESTEUR DE COH√âRENCE DES DONN√âES")
    print("Ce script v√©rifie que les donn√©es affich√©es dans le tableau de bord")
    print("correspondent exactement aux donn√©es stock√©es dans la base SQLite.")
    print()
    
    # V√©rifier que le serveur est accessible
    try:
        response = requests.get("http://localhost:5001", timeout=5)
        print("‚úÖ Serveur dashboard accessible")
    except Exception as e:
        print(f"‚ùå Serveur non accessible: {e}")
        print("   D√©marrez le dashboard avec: python admin_dashboard.py")
        return
    
    # V√©rifier que la base de donn√©es existe
    try:
        conn = sqlite3.connect("attendance.db")
        conn.close()
        print("‚úÖ Base de donn√©es SQLite accessible")
    except Exception as e:
        print(f"‚ùå Base de donn√©es non accessible: {e}")
        return
    
    # Ex√©cuter le test
    tester = DataConsistencyTester()
    success = tester.run_full_comparison()
    
    if success:
        print("\nüí° RECOMMANDATIONS:")
        print("   üéØ Vos donn√©es sont coh√©rentes et fiables")
        print("   üéØ Le dashboard peut √™tre utilis√© en toute confiance")
        print("   üéØ Aucune action corrective n√©cessaire")
    else:
        print("\nüí° ACTIONS RECOMMAND√âES:")
        print("   üîß Red√©marrer l'application dashboard")
        print("   üîß V√©rifier les requ√™tes SQL dans le code")
        print("   üîß Nettoyer les caches √©ventuels")
        print("   üîß V√©rifier l'int√©grit√© de la base de donn√©es")

if __name__ == "__main__":
    main()
